Reflection Questions 

1. How long did you spend on this assignment?
I spent around three hours completing this assignment. Most of the time went into reviewing the logic of Dijkstra’s algorithm and implementing it correctly in C++. I also tested different cases to make sure the program outputs both the shortest distance and the corresponding path. Debugging required effort because I had to ensure the graph structure and priority queue updates worked properly. Writing the code itself took about an hour, while debugging and testing scenarios took the remaining time. Overall, the experience helped me reinforce my understanding of graph algorithms and their implementation in C++.

2. Based on your effort, what letter grade would you say you earned?
Based on the effort I invested in this assignment, I believe I earned an A grade. I thoroughly reviewed Dijkstra’s algorithm, wrote clean and readable C++ code, and ensured the solution was both functional and logically correct. I also added proper graph construction, path reconstruction, and user inputs for start and end nodes. The implementation was tested with multiple inputs to confirm accuracy. Since I worked consistently and covered both the algorithm and testing process, my effort reflects a complete understanding of the problem, and I feel confident that the submitted solution meets all requirements of the assignment.

3. Based on your solution, what letter grade would you say you earned?
I would say I earned an A grade based on the correctness and completeness of the solution. The program successfully applies Dijkstra’s algorithm, asks the user for input, and displays both the shortest distance and the path. It is implemented in C++ using standard libraries and structured in a clear way. The program handles graphs correctly, reconstructs the shortest path, and avoids common pitfalls such as infinite distances. While the solution could be extended with error handling or larger graph support, the core requirements are fully met. Therefore, I am confident that this solution demonstrates strong problem-solving skills.

4. Provide a summary of what doesn't work in your solution, along with an explanation of how you attempted to solve the problem and where you feel you struggled.
Overall, the solution works as intended for the example graph. However, the program currently requires the graph to be hardcoded, and it does not allow dynamic input of nodes and edges from the user. Another limitation is that the implementation assumes the graph nodes are labeled as integers from 0 to n-1. I attempted to make the program more flexible by considering string-based node labels, but handling them with unordered maps became tricky within the given time. My struggle was mainly balancing between simplicity and flexibility. Despite these limitations, the algorithm itself is correct and performs as expected.
